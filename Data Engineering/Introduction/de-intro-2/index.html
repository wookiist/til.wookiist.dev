<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">CH2 - 빅데이터의 탐색 | wookiist TIL</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://til.wookiist.dev/Data Engineering/Introduction/de-intro-2"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="CH2 - 빅데이터의 탐색 | wookiist TIL"><meta data-react-helmet="true" name="description" content="데이터양이 증가함에 따라 집계에 걸리는 시간은 길어진다. 데이터 집계에 분 단위로 소요가 된다면 작업 효율은 그 이상으로 악화한다."><meta data-react-helmet="true" property="og:description" content="데이터양이 증가함에 따라 집계에 걸리는 시간은 길어진다. 데이터 집계에 분 단위로 소요가 된다면 작업 효율은 그 이상으로 악화한다."><link data-react-helmet="true" rel="shortcut icon" href="/img/wookii.ico"><link data-react-helmet="true" rel="canonical" href="https://til.wookiist.dev/Data Engineering/Introduction/de-intro-2"><link data-react-helmet="true" rel="alternate" href="https://til.wookiist.dev/Data Engineering/Introduction/de-intro-2" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://til.wookiist.dev/Data Engineering/Introduction/de-intro-2" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.bd468769.css">
<link rel="preload" href="/assets/js/runtime~main.63a38391.js" as="script">
<link rel="preload" href="/assets/js/main.7e56d1de.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="wookiist TIL" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/img/logo.svg" alt="wookiist TIL" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><b class="navbar__title">wookiist TIL</b></a><a class="navbar__item navbar__link navbar__link--active" href="/">Docs</a></div><div class="navbar__items navbar__items--right"><a href="https://wookiist.dev" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><a href="https://github.com/wookiist" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_2i4l react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button class="clean-btn backToTopButton_i9tI" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh menuWithAnnouncementBar_+O1J"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/">MAIN</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Data Engineering</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Airflow</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Druid</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Flink</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Hadoop</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">Introduction</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/Data Engineering/Introduction/de-terms">Data Engineering Terms</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">StudyGroup</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/Data Engineering/Introduction/de-intro-1">CH1 - 빅데이터의 기초 지식</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/Data Engineering/Introduction/de-intro-2">CH2 - 빅데이터의 탐색</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/Data Engineering/Introduction/de-intro-4">CH4 - 빅데이터의 축적</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/Data Engineering/Introduction/de-intro-5">CH5 - 빅데이터의 파이프라인</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Spark</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Sqoop</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/Data Engineering/data-pipeline-components">데이터 파이프라인 요소 정리</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Linux</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Monitoring</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">SQL</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/test">test</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">wookiist</a></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>데이터베이스의 지연을 줄이기</h1></header><p>데이터양이 증가함에 따라 집계에 걸리는 시간은 길어진다. 데이터 집계에 분 단위로 소요가 된다면 작업 효율은 그 이상으로 악화한다. </p><p>초 단위로 데이터를 집계하려면 처음부터 그것에 맞게 시스템을 마련해야 한다. </p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="데이터-처리의-지연"></a>데이터 처리의 지연<a class="hash-link" href="#데이터-처리의-지연" title="Direct link to heading">#</a></h2><p>가장 간단한 방법은 모든 데이터를 메모리에 올리는 것이다. 한 레코드의 크기가 500B이고 천만 개의 레코드가 있다고 가정하면 5GB가 된다. 이 정도라면 MySQL, PostgreSQL 등의 일반적인 RDB가 데이터 마트에 적합하다. </p><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>RDB는 지연이 적고, 많은 수의 클라이언트가 동시 접속해도 성능이 나빠지지 않으므로 많은 사용자가 사용하는 실제 운영 환경의 데이터 마트로 특히 우수하다.
그러나 RDB는 메모리가 부족하면 성능이 급격히 저하된다. 수억 레코드를 초과하는 데이터 집계에서는 항상 <strong>디바이스 I/O</strong>가 발생한다고 가정하고 이것을 어떻게 효율화할 것인지가 중요하다.</p></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="압축과-분산에-의해-지연-줄이기"></a>압축과 분산에 의해 지연 줄이기<a class="hash-link" href="#압축과-분산에-의해-지연-줄이기" title="Direct link to heading">#</a></h2><p>고속화를 위해 사용되는 기법이 &#x27;압축&#x27;과 &#x27;분산&#x27;이다. 데이터를 가능한 한 작게 압축하고 그것을 여러 디스크에 분산함으로써 데이터의 로드에 따른 지연을 줄인다.</p><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>분산된 데이터를 읽어 들이려면 <strong>멀티 코어를 활용하면서 디스크 I/O를 병렬 처리하는 것이 효과적이다.</strong> 이러한 아키텍처를 <strong>MPP (Massive Parallel Processing, 대규모 병렬 처리)</strong> 라고 한다. 대표적으로 Amazon Redshift와 Google BigQuery 등이 있다.</p></div></div><header><h1>열 지향 데이터베이스 접근</h1></header><p>칼럼을 압축하여 디스크 I/O를 줄인다.</p><p>빅데이터로 취급되는 데이터의 대부분은 디스크 상에 있다. 따라서 쿼리에 필요한 최소한의 데이터만을 가져옴으로써 지연을 줄일 수 있다. 이를 위해 <strong>칼럼 단위로의 데이터 압축</strong>을 한다. </p><p>일반적인 DB는 레코드 단위의 읽고 쓰기에 최적화되어 있으며, 이를 행 지향 데이터베이스(row-oriented database)라고 한다. </p><p>반면에 데이터 분석에 사용되는 DB는 <strong>칼럼 단위의 집계에 최적화되어 있으며, 열 지향 데이터베이스(Column-Oriented Database) 또는 칼럼 지향 데이터베이스(Columnar Database)라고 한다.</strong> </p><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>처리량(throughput)은 일정 시간 안에 처리할 수 있는 데이터의 양을 의미한다. 처리량은 배치 처리 등의 대규모 데이터 처리에서 중요시된다.
지연(delay)는 데이터 처리가 끝날 때까지의 대기 시간을 의미한다. 주로 애드 혹 데이터 분석 등에서 중요시된다.
데이터 웨어하우스나 데이터 레이크는 대량의 데이터를 처리하기 위해 주로 <strong>처리량을 중시</strong>한다. 반면 데이터 마트에 요구되는 것은 <strong>지연 시간의 단축</strong>이다. 따라서 충분한 메모리를 준비하거나 디스크 I/O의 젊감이 필수적이다.</p></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="행-지향-데이터베이스"></a>행 지향 데이터베이스<a class="hash-link" href="#행-지향-데이터베이스" title="Direct link to heading">#</a></h2><p>행 지향 데이터베이스에서는 테이블의 각 행을 하나의 덩어리로 디스크에 저장한다. 새 레코드를 추가할 때 파일의 끝에 데이터를 쓸 뿐이므로 빠르게 추가할 수 있다. </p><p>행 지향 데이터베이스에서는 데이터 검색을 고속화하기 위해 인덱스를 만든다. 만일 인덱스가 없다면, 저장되는 모든 데이터를 로드해야 원하는 레코드를 찾을 수가 있으므로 많은 디스크 I/O가 발생하여 성능이 저하된다. 따라서 적절한 인덱스의 사용이 필수적이다.</p><p>그러나 데이터 분석에서는 어떤 칼럼이 사용될지 미리 알 수 없기 때문에 인덱스 작성이 거의 도움이 되지 않는다. <strong>필연적으로 대량의 데이터 분석은 항상 디스크 I/O를 동반하므로, 인덱스에 의지하지 않는 고속화 기술이 필요하다.</strong></p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="열-지향-데이터베이스"></a><strong>열 지향 데이터베이스</strong><a class="hash-link" href="#열-지향-데이터베이스" title="Direct link to heading">#</a></h2><p>예를 들어, 점포의 총 매출액을 알고 싶을 때는 고객 정보가 필요하지 않다. 행 지향 데이터베이스에서는 그러나, 레코드 단위로 데이터가 보관되므로 필요 없는 열까지도 디스크로 로드된다. </p><p>한편, 열 지향 데이터베이스에서는 데이터를 미리 칼럼 단위로 정리해둠으로써 <strong>필요한 칼럼만을 로드해 디스크 I/O를 줄인다.</strong></p><p>열 지향 데이터베이스는 <strong>데이터 압축 효율도 우수하다.</strong> 같은 칼럼에는 종종 유사한 데이터가 나열되므로, 같은 문자열의 반복은 매우 작게 압축할 수 있다.</p><header><h1>MPP 데이터베이스의 접근 방식</h1></header><p>행 지향 데이터베이스에서 하나의 쿼리는 보통 하나의 스레드에서 실행된다. 많은 쿼리를 동시에 실행하여 여러 CPU 코어를 활용할 수 있지만, 이는 개별 쿼리가 분산 처리되는 것을 의미하진 않는다. 행 지향 데이터베이스에서 각 쿼리는 충분히 짧은 시간 안에 끝나는 것으로 생각하기 때문에 이를 분산 처리하는 것은 가정하지 않는 것이 일반적이다.</p><p>반면, 열 지향 데이터베이스에서는 디스크에서 대량의 데이터를 읽기 때문에 한번의 쿼리 실행 시간이 길어진다. 또한 압축된 데이터를 펼치는 등의 CPU 리소스도 소모하므로 멀티 코어를 활용해서 고속화하는 것이 좋다. </p><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>MPP에서는 하나의 쿼리를 다수의 작은 태스크로 분해하고, 이를 가능한 한 병렬로 실행한다. </p></div></div><p>예를 들어, 1억 레코드로 이루어진 테이블의 합계를 계산하기 위해 10만 레코드로 구분해서 1000개의 태스크로 분할하는 것이다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="mpp-데이터베이스와-대화형-쿼리-엔진"></a>MPP 데이터베이스와 대화형 쿼리 엔진<a class="hash-link" href="#mpp-데이터베이스와-대화형-쿼리-엔진" title="Direct link to heading">#</a></h2><p>쿼리가 잘 병렬화할 수 있다면, MPP를 활용한 데이터 집계는 CPU 코어 수에 비례하여 고속화된다. <strong>단, 디스크로부터의 로드가 병목 현상이 발생하지 않도록 데이터가 고르게 분산되어 있어야 한다.</strong> </p><p>MPP는 구조상, 고속화를 위해 CPU와 디스크가 모두 균형 있게 늘려야 한다.</p><p>MPP의 아키텍처는 Hadoop과 함께 사용되는 대화형 쿼리 엔진으로도 채택되고 있다. 이 경우 데이터를 저장하는 것은 분산 스토리지의 역할이다. 그러나 데이터가 열 지향으로 압축되지 않는 한 MPP 데이터베이스와 동등한 성능은 되지 못한다. 따라서 Hadoop 상에서 열 지향 스토리지를 만들기 위해 여러 라이브러리가 개발되고 있다. </p><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>열 지향 스토리지와 MPP에 의한 고속화를 할 때는 <strong>리소스의 소비를 제한해야 한다.</strong> 하나의 쿼리가 다수의 코어를 활용하면, 시스템의 모든 컴퓨트 리소스를 쉽게 소진한다는 뜻도 되며, 누군가 한 명이 실수로 거대한 쿼리를 실행하면 다른 모든 사용자가 그 영향을 받는다.</p></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/wookiist/twl/edit/documentation/docs/Data Engineering/Introduction/de-intro-2.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"><span class="theme-last-updated">Last updated on <b><time datetime="2021-10-11T23:45:37.000Z">10/11/2021</time></b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/Data Engineering/Introduction/de-intro-1"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« CH1 - 빅데이터의 기초 지식</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/Data Engineering/Introduction/de-intro-4"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">CH4 - 빅데이터의 축적 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#데이터-처리의-지연" class="table-of-contents__link">데이터 처리의 지연</a></li><li><a href="#압축과-분산에-의해-지연-줄이기" class="table-of-contents__link">압축과 분산에 의해 지연 줄이기</a></li><li><a href="#행-지향-데이터베이스" class="table-of-contents__link">행 지향 데이터베이스</a></li><li><a href="#열-지향-데이터베이스" class="table-of-contents__link"><strong>열 지향 데이터베이스</strong></a></li><li><a href="#mpp-데이터베이스와-대화형-쿼리-엔진" class="table-of-contents__link">MPP 데이터베이스와 대화형 쿼리 엔진</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 wookiist. Built by wookiist and with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.63a38391.js"></script>
<script src="/assets/js/main.7e56d1de.js"></script>
</body>
</html>